%% This function is used to update data matrices with solutio
function [bus, gen, branch]=pfsoln(baseMVA, bus, gen, branch, Ybus, Yf, Yt, V, ref, pv, pq)
    %% update Vm and Va for buses data
    %Call indexing function
    index_bus=idx_bus();%Index for bus matrix
    index_branch=idx_brch();%Index for branch matrix
    index_gen=idx_gen();%Index for generator matrix   
    
    %Initialize return values
    bus(:, index_bus.VM)=abs(V);
    bus(:, index_bus.VA)=angle(V) * 180 / pi;
    
    %% update Qg for gens at PV/slack buses and Pg for slack bus(es)
    %generator data
    on=find((gen(:, index_gen.GEN_STATUS)>0).*(bus(gen(:, index_gen.GEN_BUS), index_bus.BUS_TYPE) ~= index_bus.PQ));   % Which generators are on and not at PQ buses?
    off = find(gen(:, index_gen.GEN_STATUS) <= 0);  % Which generators are off?
    gbus =gen(on, index_gen.GEN_BUS);  % What buses are they at?
    %Compute total injected bus powers 
    Sbus = V(gbus) .* conj(Ybus(gbus, :) * V);
    %Update Qg for generators at PV/slack buse
    gen(off, index_gen.QG) = 0;% Zero out off-line Qg
    [Pd_gbus, Qd_gbus] = total_load(bus(gbus, :));
    gen(on, index_gen.QG)=imag(Sbus)*baseMVA+Qd_gbus;%inj Q + local Qd
    if length(on) > 1
        %build connection matrix, element i, j is 1 if gen on(i) at bus j is ON
        nb = size(bus, 1);
        ngon = size(on, 1);
        Cg = sparse((1:ngon)', gbus, ones(ngon, 1), ngon, nb);
        %% divide Qg by number of generators at the bus to distribute equally
        ngg = Cg * sum(Cg)';%ngon x 1, number of gens at this gen's bus
        gen(on, index_gen.QG)= gen(on, index_gen.QG) ./ ngg;
        %set finite proxy M for infinite limits (for ~ proportional splitting)
        %equal to sum over all gens at bus of abs(Qg) plus any finite Q limits
        Qmin = gen(on, index_gen.QMIN);
        Qmax = gen(on, index_gen.QMAX);
        M = abs(gen(on, index_gen.QG));
        M(~isinf(Qmax)) =M(~isinf(Qmax)) + abs(Qmax(~isinf(Qmax)));
        M(~isinf(Qmin)) = M(~isinf(Qmin)) + abs(Qmin(~isinf(Qmin)));
        M = Cg * Cg' * M;%each gen gets sum over all gens at same bus
        %% replace +/- Inf limits with proxy +/- M
        Qmin(Qmin==Inf) =  M(Qmin==Inf);
        Qmin(Qmin==-Inf) = -M(Qmin==-Inf);
        Qmax(Qmax==Inf) =  M(Qmax==Inf);
        Qmax(Qmax==-Inf) = -M(Qmax==-Inf);
        %% divide proportionally
        Cmin = sparse((1:ngon)', gbus, Qmin, ngon, nb);
        Cmax = sparse((1:ngon)', gbus, Qmax, ngon, nb);
        Qg_tot = Cg' * gen(on, index_gen.QG);%nb x 1 vector of total Qg at each bus
        Qg_min = sparse(sum(Cmin)');%nb x 1 vector of min total Qg at each bus
        Qg_max = sparse(sum(Cmax)');%nb x 1 vector of max total Qg atTuple(i)(1) each bus
        eps = 2.2204e-16;
        gen(on, index_gen.QG) = Qmin + (Cg * ((Qg_tot - Qg_min) ./ (Qg_max - Qg_min + eps))) .* (Qmax - Qmin);%avoid div by 0
       %% fix gens at buses with Qg range = 0 (use equal violation for all)
        %To do for the correction
        ig = find(abs(Cg * (Qg_min - Qg_max)) < 10*eps);  %% gens at buses with Qg range = 0
        if ~isempty(ig)
            ib = find(sum(Cg(ig,:), 1)');   %% buses with Qg range = 0
            % total mismatch @ bus div by number of gens
            mis = sparse(ib, 1, (Qg_tot(ib) - Qg_min(ib)) ./ sum(Cg(:, ib)', 2), nb, 1);
            gen(on(ig), QG) = Qmin(ig) + Cg(ig, :) * mis;
        end
    end      
    for k = 1 : length(ref)
         refgen = find(gbus== ref(k));%which is(are) the reference gen(s)?
         [Pd_refk, Qd_refk] = total_load(bus(ref(k), :));
         gen(on(refgen(1)), index_gen.PG) = real(Sbus(refgen(1))) * baseMVA + Pd_refk(1, 1);%inj P + local Pd
         if length(refgen) > 1%more than one generator at this ref bus
             %subtract off what is generated by other gens at this bus
             gen(on(refgen(1)), index_gen.PG) = gen(on(refgen(1)), index_gen.PG) - sum(gen(on(refgen(2:end)), index_gen.PG));
         end
     end

%%----- update/compute branch power flows -----
out = find(branch(:, index_branch.BR_STATUS) == 0);      %% out-of-service branches
br = find(branch(:, index_branch.BR_STATUS));            %% in-service branches
Sf = V(branch(br, index_branch.F_BUS)) .* conj(Yf(br, :) * V) * baseMVA; %% complex power at "from" bus
St = V(branch(br, index_branch.T_BUS)) .* conj(Yt(br, :) * V) * baseMVA; %% complex power injected at "to" bus
branch(br, [index_branch.PF, index_branch.QF, index_branch.PT, index_branch.QT]) = [real(Sf) imag(Sf) real(St) imag(St)];
branch(out, [index_branch.PF, index_branch.QF, index_branch.PT, index_branch.QT]) = zeros(length(out), 4);
end